<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>F!RST — Local Prototype</title>
<style>
  :root{
    --bg:#0e0f12; --panel:#151821; --text:#f2f5fb; --muted:#aab3c2; --accent:#8fb1ff;
    --card:#1d2230; --card-b:#2c3447; --slot:#1b1f2a; --slot-b:#2a3142;
    --btn:#222737; --btn-h:#2a3150; --warn:#ffd36b; --bad:#ff6b6b; --good:#6bff87;
    --outline:#3b4562;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;gap:10px}
  h1{font-size:18px;margin:0;color:var(--accent);display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .bar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{padding:4px 8px;border-radius:999px;border:1px solid #2a3142;background:#161b28;color:#c8d2ee;font-size:12px}
  .btn{background:var(--btn);color:var(--text);border:1px solid #2a3142;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn:hover{background:var(--btn-h)}
  .icon-btn{width:32px;height:32px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:900}
  .help{font-size:18px}
  /* Layout */
  .layout{
    display:grid;
    grid-template-columns: 1fr minmax(180px, 260px);
    grid-auto-rows:min-content;
    gap:10px;
  }
  .panel{background:var(--panel);border:1px solid #232a3a;border-radius:12px;padding:10px}
  .title{font-weight:700;margin-bottom:6px;font-size:14px;color:#dbe5ff}
  .zone{display:flex;gap:8px;flex-wrap:wrap}
  .zone.compact{gap:6px}
  .slot{min-width:clamp(84px,16vw,140px);min-height:clamp(90px,18vw,120px);border:1px dashed var(--slot-b);border-radius:12px;background:var(--slot);display:flex;align-items:center;justify-content:center;position:relative}
  .card{
    width:clamp(84px,16vw,140px);height:clamp(90px,18vw,120px);
    border-radius:10px;border:1px solid var(--card-b);
    background:var(--card);display:flex;flex-direction:column;align-items:center;justify-content:center;
    text-align:center;position:relative;
  }
  .card.clickable{cursor:pointer}
  .card.clickable:hover{outline:2px solid var(--outline)}
  .L{font-size:clamp(44px,10vw,64px);font-weight:900;letter-spacing:2px;line-height:1}
  /* Right column blocks stacked */
  .stack{display:flex;flex-direction:column;gap:10px}
  /* Hand and Log at bottom */
  .footer-col{margin-top:10px;display:flex;flex-direction:column;gap:10px}
  .hand{position:relative}
  .log{height:160px;overflow:auto;background:#0f1320;border:1px solid #232a3a;border-radius:12px;padding:10px;color:#c6d0ec;font-size:13px;line-height:1.35}
  .log .entry{margin-bottom:6px;opacity:0.95}
  /* Modal (choices) */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;padding:16px;z-index:20}
  .modal > .box{background:#0f1320;border:1px solid #2a3142;border-radius:12px;max-width:560px;width:100%;padding:14px}
  .modal .title{margin-bottom:8px}
  .choices{display:flex;gap:8px;flex-wrap:wrap}
  .choice{padding:8px 12px;border:1px solid #2a3142;border-radius:10px;background:#161b28;color:#dbe5ff;cursor:pointer}
  .choice:hover{outline:2px solid var(--outline)}
  /* Help modal */
  .helpbox .content{font-size:14px;color:#dfe7ff;line-height:1.5}
  .helpbox h3{margin:8px 0 4px 0;font-size:15px;color:#a7b7ff}
  .helpbox code{background:#13182a;padding:0 6px;border-radius:6px;border:1px solid #263052}
  /* Toast */
  .toast{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#111522;border:1px solid #232a3a;padding:10px 14px;border-radius:10px;color:#e7ecff;font-size:13px;display:none;z-index:25}
  /* Animations */
  @keyframes drop-in {0%{transform:translateY(-12px) scale(.96);opacity:0}100%{transform:translateY(0) scale(1);opacity:1}}
  @keyframes pop-in  {0%{transform:scale(.9);opacity:0}100%{transform:scale(1);opacity:1}}
  .enter-board{animation:drop-in .25s ease-out}
  .enter-discard{animation:pop-in .22s ease-out}
  /* Responsive tweaks */
  @media (max-width: 820px){
    .layout{grid-template-columns:1fr;gap:10px}
    .stack{flex-direction:row;overflow:auto}
    .stack .panel{min-width:240px}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>F!RST — prototype</h1>
    <div class="bar">
      <span class="pill">Turn: <b id="turnLbl">—</b></span>
      <span class="pill">Dice: <b id="diceLbl">—</b></span>
      <span class="pill">Your hand: <b id="youHandCount">0</b>/7</span>
      <span class="pill">AI hand: <b id="aiHandCount">0</b> (hidden)</span>
      <button class="btn" id="restartBtn">Restart</button>
      <button class="btn icon-btn help" id="helpBtn">?</button>
    </div>
  </header>

  <main class="layout">
    <!-- Left column: boards -->
    <div class="panel">
      <div class="title">SPACE — AI</div>
      <div id="aiSpace" class="zone"></div>
    </div>

    <!-- Right column top: AI discard -->
    <div class="stack">
      <div class="panel">
        <div class="title">DISCARD — AI</div>
        <div id="aiDiscard" class="zone compact"></div>
      </div>

      <div class="panel">
        <div class="title">DISCARD — You</div>
        <div id="youDiscard" class="zone compact"></div>
      </div>
    </div>

    <!-- Left column second row: player space -->
    <div class="panel">
      <div class="title">SPACE — You</div>
      <div id="youSpace" class="zone"></div>
    </div>

    <!-- (Right column keeps the stack; grid auto-flow fills left->right->left etc.) -->

    <!-- Bottom: your hand and log -->
    <div class="footer-col" style="grid-column: 1 / -1;">
      <div class="panel hand">
        <div class="title">Your hand <span style="color:var(--muted);font-size:12px">(click a card to play)</span></div>
        <div id="youHand" class="zone"></div>
      </div>
      <div class="panel">
        <div class="title">Game log</div>
        <div id="log" class="log"></div>
      </div>
    </div>
  </main>
</div>

<!-- Choice modal -->
<div class="modal" id="modal">
  <div class="box">
    <div class="title" id="modalTitle">Choose</div>
    <div class="choices" id="modalChoices"></div>
  </div>
</div>

<!-- Help modal -->
<div class="modal" id="helpModal">
  <div class="box helpbox">
    <div class="title">F!RST — rules & cards</div>
    <div class="content">
      <h3>Objective</h3>
      First to assemble <b>F I R S T</b> in your SPACE, <i>or</i> to have <b>5 of the same letter</b> in your SPACE, wins.
      <h3>Setup</h3>
      Each player has a 50-card deck: 10×<b>F</b>, 10×<b>I</b>, 10×<b>R</b>, 10×<b>S</b>, 10×<b>T</b>. Draw 5 cards to start. Roll dice to choose who goes first.
      <h3>Turn</h3>
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li><b>Draw step:</b> draw 1 (except the very first turn of the first player).</li>
        <li><b>Play step:</b> play exactly one card; its effect resolves.</li>
        <li><b>End:</b> turn ends automatically.</li>
      </ul>
      <h3>Cards</h3>
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li><b>F</b> (<i>Forbid</i>): choose a letter; the next time the opponent plays that letter, it goes to their DISCARD and does not enter SPACE.</li>
        <li><b>I</b> (<i>Increase</i>): draw 1. Hand limit 7; excess goes to DISCARD.</li>
        <li><b>R</b> (<i>Recover</i>): return 1 card from your DISCARD to your hand.</li>
        <li><b>S</b> (<i>Steal</i>): move 1 card from opponent’s SPACE to their DISCARD.</li>
        <li><b>T</b> (<i>Trap</i>): on the opponent’s next turn, after draw they discard 1 card. Stacks.</li>
      </ul>
      <h3>Additional</h3>
      If you ever must draw but your deck is empty — you lose. Max hand size: 7.
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
        <button class="btn" id="closeHelp">Close</button>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* =========================
   State & constants
   ========================= */
const TYPES = ['F','I','R','S','T'];

let G;

function newGame(){
  G = {
    turn: null,                 // 'you' | 'ai'
    firstPlayer: null,
    firstTurnDone: false,       // to skip first draw for the first player
    you: sideState(),
    ai:  sideState(),
    traps: {
      forbidYou: null,          // one-shot letter forbidden for YOU (set by AI)
      forbidAI:  null,          // one-shot letter forbidden for AI (set by YOU)
      tNextYou:  0,             // how many cards YOU must discard next turn (from T)
      tNextAI:   0
    },
    over:false,
    log:[]
  };
  shuffle(G.you.deck); shuffle(G.ai.deck);
  draw('you',5); draw('ai',5);

  // dice roll
  const dYou = 1+Math.floor(Math.random()*6);
  const dAI  = 1+Math.floor(Math.random()*6);
  let text = `You: ${dYou} • AI: ${dAI}`;
  if(dYou===dAI){
    // reroll until different
    while(true){
      const a=1+Math.floor(Math.random()*6), b=1+Math.floor(Math.random()*6);
      if(a!==b){ text += ` → reroll: You ${a} • AI ${b}`; G.firstPlayer = (a>b)?'you':'ai'; break; }
    }
  }else{
    G.firstPlayer = (dYou>dAI)?'you':'ai';
  }
  setDice(`${text} — ${G.firstPlayer==='you'?'You go first.':'AI goes first.'}`);
  G.turn = G.firstPlayer;
  render();
  setTimeout(()=> startTurn(), 450);
}

function sideState(){
  return {
    deck: buildDeck(),
    hand: [],
    space: [],
    discard: []
  };
}
function buildDeck(){
  const d=[];
  for(let i=0;i<10;i++) for(const t of TYPES) d.push(t);
  return d;
}

/* =========================
   Utils
   ========================= */
function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

function addLog(s){
  G.log.push(s);
  const el = document.getElementById('log');
  const div = document.createElement('div');
  div.className='entry';
  div.textContent = s;
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;
}

function toast(msg){
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.style.display = 'block';
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>{ el.style.display='none'; }, 1900);
}

function setDice(s){ document.getElementById('diceLbl').textContent = s; }
function setStatusTurn(){ document.getElementById('turnLbl').textContent = G.over ? 'Game over' : (G.turn==='you'?'You':'AI'); }

/* =========================
   Draw & limits
   ========================= */
function draw(side, n){
  const S = (side==='you')?G.you:G.ai;
  for(let i=0;i<n;i++){
    if(S.deck.length===0){
      // Forced draw with empty deck => defeat
      defeat(side);
      return;
    }
    const c = S.deck.pop();
    S.hand.push(c);
    addLog(`${side==='you'?'You':'AI'} drew a card.`);
    enforceHandLimit(side);
    if(G.over) return;
  }
}

function enforceHandLimit(side){
  const S = side==='you'?G.you:G.ai;
  while(S.hand.length>7){
    const overflow = S.hand.pop();
    S.discard.push(overflow);
    addLog(`${side==='you'?'Your':'AI\'s'} hand overflow: ${overflow} moved to DISCARD.`);
    animateZone(side==='you'?'youDiscard':'aiDiscard');
  }
}

/* =========================
   Turn flow
   ========================= */
function startTurn(){
  if(G.over) return;
  setStatusTurn();
  const side = G.turn;

  // DRAW STEP (skip only first turn of first player)
  const skip = (!G.firstTurnDone && G.turn===G.firstPlayer);
  if(!skip){
    draw(side,1);
    if(G.over) return;
  }
  if(!G.firstTurnDone) G.firstTurnDone = true;

  // T traps — forced discard after draw
  if(side==='you' && G.traps.tNextYou>0){
    const toDiscard = Math.min(G.traps.tNextYou, G.you.hand.length);
    if(toDiscard>0){
      chooseIndex('Trap (T): choose a card to discard', G.you.hand, (idx)=>{
        const dumped = G.you.hand.splice(idx,1)[0];
        G.you.discard.push(dumped);
        addLog(`Trap: you discarded ${dumped}.`);
        animateZone('youDiscard');
        G.traps.tNextYou = 0;
        render();
        // Now you can play (unless hand empty)
        if(G.turn==='ai' || G.over) return; // safety
      });
      return; // wait for modal selection
    }else{
      G.traps.tNextYou = 0;
    }
  }
  if(side==='ai' && G.traps.tNextAI>0){
    const toDiscard = Math.min(G.traps.tNextAI, G.ai.hand.length);
    if(toDiscard>0){
      const dumped = G.ai.hand.splice(Math.floor(Math.random()*G.ai.hand.length),1)[0];
      G.ai.discard.push(dumped);
      addLog(`Trap: AI discarded a card.`);
      animateZone('aiDiscard');
    }
    G.traps.tNextAI = 0;
  }

  render();

  // If AI's turn, autoplay
  if(side==='ai'){
    setTimeout(aiPlay, 500);
  }
}

function endTurn(){
  if(G.over) return;
  G.turn = (G.turn==='you')?'ai':'you';
  render();
  setTimeout(()=>startTurn(), 350);
}

function defeat(side){
  if(G.over) return;
  G.over = true;
  const msg = side==='you' ? 'Defeat: your deck was empty when you had to draw.' : 'Victory: AI had no cards to draw.';
  addLog(msg);
  alert(msg);
  render();
}

function checkWin(){
  function hasFIRST(space){
    const set = new Set(space);
    return TYPES.every(t=>set.has(t));
  }
  function hasFiveSame(space){
    const cnt = {F:0,I:0,R:0,S:0,T:0};
    space.forEach(c=>cnt[c]++);
    return Object.values(cnt).some(x=>x>=5);
  }
  let youWin = hasFIRST(G.you.space) || hasFiveSame(G.you.space);
  let aiWin  = hasFIRST(G.ai.space)  || hasFiveSame(G.ai.space);
  if(youWin || aiWin){
    G.over = true;
    const msg = youWin && !aiWin ? 'Victory! You assembled the combo.' :
                (!youWin && aiWin ? 'Defeat: AI assembled the combo.' :
                'Draw: both assembled a combo.');
    addLog(msg);
    alert(msg);
    render();
    return true;
  }
  return false;
}

/* =========================
   Playing a card (You)
   ========================= */
function playFromHand(index){
  if(G.over) return;
  if(G.turn!=='you') return;
  const letter = G.you.hand[index];
  if(!letter) return;

  // Opponent's Forbid on YOU
  if(G.traps.forbidYou === letter){
    G.traps.forbidYou = null; // consume the trap
    G.you.discard.push(letter);
    G.you.hand.splice(index,1);
    addLog(`Forbid triggered against you: ${letter} went to your DISCARD.`);
    animateZone('youDiscard');
    render();
    if(!checkWin()) endTurn();
    return;
  }

  // Play: move to SPACE
  G.you.hand.splice(index,1);
  G.you.space.push(letter);
  addLog(`You played ${letter}.`);
  animateZone('youSpace');

  // Resolve effect
  resolveEffect('you', letter, ()=>{
    if(!checkWin()) endTurn();
  });
}

/* =========================
   Effects
   ========================= */
function resolveEffect(side, letter, done){
  if(letter==='F'){
    // choose letter to forbid
    chooseType('Choose a letter to forbid', TYPES, (t)=>{
      if(side==='you'){ G.traps.forbidAI = t; addLog(`You forbade ${t} for AI.`); }
      else { G.traps.forbidYou = t; addLog(`AI forbade ${t} for you.`); }
      done();
    });
    return;
  }
  if(letter==='I'){
    draw(side,1);
    done(); return;
  }
  if(letter==='R'){
    const S = side==='you'?G.you:G.ai;
    if(S.discard.length===0){ done(); return; }
    // choose which letter to return
    chooseType('Recover: choose a letter from your DISCARD', uniqueLetters(S.discard), (pick)=>{
      const idx = S.discard.lastIndexOf(pick);
      if(idx>=0){
        const c = S.discard.splice(idx,1)[0];
        S.hand.push(c);
        addLog(`${side==='you'?'You':'AI'} recovered ${c} from DISCARD to hand.`);
        enforceHandLimit(side);
      }
      render();
      done();
    });
    return;
  }
  if(letter==='S'){
    const O = side==='you'?G.ai:G.you;
    if(O.space.length===0){ done(); return; }
    // choose which opponent SPACE card to remove
    chooseIndex('Steal: choose a card from opponent’s SPACE to discard', O.space, (i)=>{
      const removed = O.space.splice(i,1)[0];
      O.discard.push(removed);
      addLog(`${side==='you'?'You':'AI'} moved opponent’s ${removed} from SPACE to DISCARD.`);
      animateZone(side==='you'?'aiDiscard':'youDiscard');
      render();
      done();
    });
    return;
  }
  if(letter==='T'){
    if(side==='you'){ G.traps.tNextAI++; addLog('You set a Trap (T): AI will discard 1 at start of next turn.'); }
    else { G.traps.tNextYou++; addLog('AI set a Trap (T): you will discard 1 at start of next turn.'); }
    done(); return;
  }
  done();
}

function uniqueLetters(arr){ return Array.from(new Set(arr)); }

/* =========================
   AI
   ========================= */
function aiPlay(){
  if(G.over || G.turn!=='ai') return;

  const hand = G.ai.hand.slice();
  if(hand.length===0){ endTurn(); return; }

  // Choose a card by simple priority
  function freq(arr){ const m={}; for(const x of arr){m[x]=(m[x]||0)+1;} return m; }
  const youFreq = freq(G.you.space);
  const mostType = Object.entries(youFreq).sort((a,b)=>b[1]-a[1])[0]?.[0] || TYPES[Math.floor(Math.random()*5)];

  let idx = -1;

  if(G.you.space.length>0) idx = hand.indexOf('S');                // S (disrupt)
  if(idx<0 && G.ai.discard.length>0) idx = hand.indexOf('R');      // R (value)
  if(idx<0) idx = hand.indexOf('F');                               // F (meta)
  if(idx<0) idx = hand.indexOf('T');                               // T (tempo)
  if(idx<0) idx = hand.indexOf('I');                               // I (draw)
  if(idx<0) idx = 0;

  const letter = hand[idx];

  // Your Forbid on AI?
  if(G.traps.forbidAI === letter){
    G.traps.forbidAI = null;
    G.ai.discard.push(letter);
    G.ai.hand.splice(idx,1);
    addLog(`Forbid triggered on AI: ${letter} went to AI’s DISCARD.`);
    animateZone('aiDiscard');
    render();
    if(!checkWin()) endTurn();
    return;
  }

  // Play to SPACE
  G.ai.hand.splice(idx,1);
  G.ai.space.push(letter);
  addLog(`AI played ${letter}.`);
  animateZone('aiSpace');
  render();

  // Resolve effect
  if(letter==='F'){
    const t = mostType;
    G.traps.forbidYou = t;
    addLog(`AI forbade ${t} for you.`);
    finalize(); return;
  }
  if(letter==='I'){
    draw('ai',1); finalize(); return;
  }
  if(letter==='R'){
    if(G.ai.discard.length>0){
      const pick = G.ai.discard.pop();
      G.ai.hand.push(pick);
      addLog('AI recovered a card from DISCARD.');
      enforceHandLimit('ai');
    }
    finalize(); return;
  }
  if(letter==='S'){
    if(G.you.space.length>0){
      const removed = G.you.space.pop();
      G.you.discard.push(removed);
      addLog('AI stole a card from your SPACE to your DISCARD.');
      animateZone('youDiscard');
    }
    finalize(); return;
  }
  if(letter==='T'){
    G.traps.tNextYou++; addLog('AI set a Trap (T): you will discard 1 next turn.');
    finalize(); return;
  }
  finalize();

  function finalize(){
    if(!checkWin()) endTurn();
  }
}

/* =========================
   Rendering
   ========================= */
function render(){
  setStatusTurn();

  // Hand counts
  document.getElementById('youHandCount').textContent = G.you.hand.length;
  document.getElementById('aiHandCount').textContent  = G.ai.hand.length;

  // SPACE
  const ys = document.getElementById('youSpace'); ys.innerHTML='';
  G.you.space.forEach((c,i)=> ys.appendChild(cardEl(c, false, null, i===G.you.space.length-1 && lastAnimZone==='youSpace')));

  const as = document.getElementById('aiSpace'); as.innerHTML='';
  G.ai.space.forEach((c,i)=> as.appendChild(cardEl(c, false, null, i===G.ai.space.length-1 && lastAnimZone==='aiSpace')));

  // DISCARD (show reversed for visual recency)
  const yd = document.getElementById('youDiscard'); yd.innerHTML='';
  G.you.discard.slice().reverse().forEach((c,i,arr)=> yd.appendChild(cardEl(c,false,null, i===0 && lastAnimZone==='youDiscard', true)));

  const ad = document.getElementById('aiDiscard'); ad.innerHTML='';
  G.ai.discard.slice().reverse().forEach((c,i,arr)=> ad.appendChild(cardEl(c,false,null, i===0 && lastAnimZone==='aiDiscard', true)));

  // YOUR HAND (bottom)
  const youHand = document.getElementById('youHand'); youHand.innerHTML='';
  G.you.hand.forEach((c,i)=> youHand.appendChild(cardEl(c, G.turn==='you' && !G.over, ()=>playFromHand(i))));
}

/* Card element with optional click and animation */
function cardEl(letter, clickable=false, onClick=null, animate=false, isDiscard=false){
  const d = document.createElement('div');
  d.className = 'card' + (clickable?' clickable':'');
  if(animate) d.classList.add(isDiscard?'enter-discard':'enter-board');
  d.innerHTML = `<div class="L">${letter}</div>`;
  if(clickable && onClick) d.addEventListener('click', onClick);
  return d;
}

/* Animation helper */
let lastAnimZone = null;
function animateZone(zone){
  lastAnimZone = zone; // 'youSpace' | 'aiSpace' | 'youDiscard' | 'aiDiscard'
  // reset marker shortly after next render
  clearTimeout(animateZone._t);
  animateZone._t = setTimeout(()=>{ lastAnimZone = null; }, 300);
}

/* =========================
   Modals (choices & help)
   ========================= */
function chooseType(title, options, cb){
  const modal = document.getElementById('modal');
  const box = document.getElementById('modalChoices');
  document.getElementById('modalTitle').textContent = title;
  box.innerHTML='';
  options.forEach(o=>{
    const b = document.createElement('div');
    b.className='choice';
    b.textContent = o;
    b.addEventListener('click', ()=>{ modal.style.display='none'; cb(o); });
    box.appendChild(b);
  });
  modal.style.display='flex';
}
function chooseIndex(title, list, cb){
  const modal = document.getElementById('modal');
  const box = document.getElementById('modalChoices');
  document.getElementById('modalTitle').textContent = title;
  box.innerHTML='';
  list.forEach((letter, idx)=>{
    const el = document.createElement('div');
    el.className='choice';
    el.textContent = `${idx+1}) ${letter}`;
    el.addEventListener('click', ()=>{ modal.style.display='none'; cb(idx); });
    box.appendChild(el);
  });
  modal.style.display='flex';
}

document.getElementById('helpBtn').addEventListener('click', ()=>{
  document.getElementById('helpModal').style.display='flex';
});
document.getElementById('closeHelp').addEventListener('click', ()=>{
  document.getElementById('helpModal').style.display='none';
});
document.getElementById('helpModal').addEventListener('click', (e)=>{
  if(e.target.id==='helpModal') e.currentTarget.style.display='none';
});
document.getElementById('modal').addEventListener('click', (e)=>{
  // prevent closing by background click — must choose
  e.stopPropagation();
});

/* =========================
   Controls
   ========================= */
document.getElementById('restartBtn').addEventListener('click', ()=> {
  // clear log
  document.getElementById('log').innerHTML='';
  newGame();
});

/* =========================
   Start
   ========================= */
newGame();
</script>
</body>
</html>
